# 前端时间处理对接文档

## 📋 概述

本文档详细说明了后端API返回的时间字段格式、时区处理逻辑，以及前端应该如何正确处理和显示这些时间数据。

## 🎯 时间处理原则

### 1. 统一时区标准
- **后端业务逻辑**: 统一使用北京时间 (Asia/Shanghai)
- **数据库存储**: 统一存储UTC时间
- **API返回**: 统一返回北京时间格式
- **前端显示**: 统一显示北京时间

### 2. 时间转换流程
```
用户操作 → 前端发送北京时间 → 后端转换为UTC存储 → 后端返回北京时间 → 前端直接显示
```

## 📊 API时间字段说明

### 1. 扫码确认就餐相关时间字段

#### 1.1 扫码确认接口返回
**接口**: `POST /api/qr-scan/scan`

**返回示例**:
```json
{
  "success": true,
  "message": "登记成功！[午餐] 2025-01-15 12:30",
  "data": {
    "userId": "user123",
    "userName": "张三",
    "mealType": "lunch",
    "mealTypeName": "午餐",
    "diningDate": "2025-01-15",
    "scanTime": "2025-01-15 12:30:00",  // 北京时间格式
    "qrCodeInfo": {
      "name": "主餐厅二维码",
      "location": "主餐厅入口"
    }
  }
}
```

#### 1.2 扫码历史接口返回
**接口**: `GET /api/qr-scan/history`

**返回示例**:
```json
{
  "success": true,
  "message": "获取登记历史成功",
  "data": [
    {
      "_id": "reg123",
      "userId": "user123",
      "userName": "张三",
      "qrCode": "DINING_QR_MAIN_001",
      "qrCodeName": "主餐厅二维码",
      "qrCodeLocation": "主餐厅入口",
      "scanTime": "2025-01-15T12:30:00.000Z",  // UTC时间格式
      "scanTimeFormatted": "2025-01-15 12:30:00",  // 北京时间格式
      "mealType": "lunch",
      "mealTypeName": "午餐",
      "diningDate": "2025-01-15",
      "status": "success"
    }
  ]
}
```

### 2. 报餐相关时间字段

#### 2.1 个人报餐状态接口返回
**接口**: `GET /api/dining/personal-status`

**返回示例**:
```json
{
  "success": true,
  "message": "获取个人报餐状态成功",
  "data": {
    "userInfo": {
      "userId": "user123",
      "userName": "张三",
      "department": "技术部"
    },
    "date": "2025-01-15",
    "orders": [
      {
        "_id": "order123",
        "mealType": "lunch",
        "mealTypeName": "午餐",
        "memberCount": 1,
        "memberNames": ["张三"],
        "status": "confirmed",
        "diningStatus": "ordered",
        "createTime": "2025-01-15T01:53:00.000Z",  // UTC时间格式
        "actualDiningTime": null
      }
    ]
  }
}
```

#### 2.2 部门报餐概览接口返回
**接口**: `GET /api/dining/department-overview`

**返回示例**:
```json
{
  "success": true,
  "message": "获取部门报餐概览成功",
  "data": {
    "date": "2025-01-15",
    "departmentName": "技术部",
    "summary": {
      "totalOrders": 3,
      "totalPeople": 5,
      "breakfast": { "orders": 1, "people": 2 },
      "lunch": { "orders": 1, "people": 1 },
      "dinner": { "orders": 1, "people": 2 }
    },
    "orders": [
      {
        "_id": "order123",
        "mealType": "lunch",
        "mealTypeName": "午餐",
        "memberCount": 1,
        "memberNames": ["张三"],
        "status": "confirmed",
        "diningStatus": "ordered",
        "createTime": "2025-01-15T01:53:00.000Z",  // UTC时间格式
        "actualDiningTime": null
      }
    ]
  }
}
```

### 3. 确认就餐相关时间字段

#### 3.1 就餐确认状态接口返回
**接口**: `GET /api/dining-confirmation/status`

**返回示例**:
```json
{
  "success": true,
  "message": "获取就餐确认状态成功",
  "data": {
    "date": "2025-01-15",
    "userInfo": {
      "userId": "user123",
      "userName": "张三"
    },
    "breakfast": {
      "isRegistered": true,
      "isConfirmed": false,
      "orderId": "order123",
      "actualDiningTime": null
    },
    "lunch": {
      "isRegistered": true,
      "isConfirmed": true,
      "orderId": "order124",
      "actualDiningTime": "2025-01-15T12:30:00.000Z"  // UTC时间格式
    },
    "dinner": {
      "isRegistered": false,
      "isConfirmed": false,
      "orderId": null,
      "actualDiningTime": null
    }
  }
}
```

## 🔧 前端时间处理指南

### 1. 时间字段识别

#### 1.1 UTC时间格式字段
以下字段返回UTC时间格式，需要前端转换：
- `scanTime` (扫码时间)
- `createTime` (创建时间)
- `actualDiningTime` (实际就餐时间)
- `updateTime` (更新时间)

#### 1.2 北京时间格式字段
以下字段已返回北京时间格式，可直接显示：
- `scanTimeFormatted` (格式化扫码时间)
- `diningDate` (就餐日期)
- `message` 中的时间文本

### 2. 前端时间转换工具函数

#### 2.1 JavaScript时间转换工具
```javascript
// 时间转换工具类
class TimeUtils {
  /**
   * 将UTC时间转换为北京时间显示
   * @param {string|Date} utcTime - UTC时间
   * @param {string} format - 显示格式
   * @returns {string} 北京时间字符串
   */
  static formatToBeijing(utcTime, format = 'YYYY-MM-DD HH:mm:ss') {
    if (!utcTime) return '';
    
    // 使用moment-timezone处理时区转换
    const moment = require('moment-timezone');
    return moment(utcTime).tz('Asia/Shanghai').format(format);
  }

  /**
   * 将UTC时间转换为简化的北京时间显示
   * @param {string|Date} utcTime - UTC时间
   * @returns {string} 简化的北京时间字符串
   */
  static formatToBeijingSimple(utcTime) {
    if (!utcTime) return '';
    
    const moment = require('moment-timezone');
    const beijingTime = moment(utcTime).tz('Asia/Shanghai');
    
    // 如果是今天，只显示时间
    const today = moment().tz('Asia/Shanghai').format('YYYY-MM-DD');
    const timeDate = beijingTime.format('YYYY-MM-DD');
    
    if (timeDate === today) {
      return beijingTime.format('HH:mm');
    } else {
      return beijingTime.format('MM-DD HH:mm');
    }
  }

  /**
   * 获取当前北京时间
   * @param {string} format - 格式
   * @returns {string} 当前北京时间
   */
  static getCurrentBeijingTime(format = 'YYYY-MM-DD HH:mm:ss') {
    const moment = require('moment-timezone');
    return moment().tz('Asia/Shanghai').format(format);
  }

  /**
   * 获取今天的日期（北京时间）
   * @returns {string} 今天的日期 YYYY-MM-DD
   */
  static getTodayDate() {
    const moment = require('moment-timezone');
    return moment().tz('Asia/Shanghai').format('YYYY-MM-DD');
  }

  /**
   * 判断时间是否为今天
   * @param {string|Date} time - 时间
   * @returns {boolean} 是否为今天
   */
  static isToday(time) {
    if (!time) return false;
    
    const moment = require('moment-timezone');
    const today = moment().tz('Asia/Shanghai').format('YYYY-MM-DD');
    const timeDate = moment(time).tz('Asia/Shanghai').format('YYYY-MM-DD');
    
    return today === timeDate;
  }
}
```

#### 2.2 Vue.js时间处理组件
```vue
<template>
  <div class="time-display">
    <!-- 完整时间显示 -->
    <div class="full-time">
      {{ formatFullTime(utcTime) }}
    </div>
    
    <!-- 简化时间显示 -->
    <div class="simple-time">
      {{ formatSimpleTime(utcTime) }}
    </div>
    
    <!-- 相对时间显示 -->
    <div class="relative-time">
      {{ formatRelativeTime(utcTime) }}
    </div>
  </div>
</template>

<script>
import moment from 'moment-timezone';

export default {
  name: 'TimeDisplay',
  props: {
    utcTime: {
      type: [String, Date],
      default: null
    },
    format: {
      type: String,
      default: 'YYYY-MM-DD HH:mm:ss'
    }
  },
  methods: {
    /**
     * 格式化完整时间
     */
    formatFullTime(time) {
      if (!time) return '';
      return moment(time).tz('Asia/Shanghai').format(this.format);
    },

    /**
     * 格式化简化时间
     */
    formatSimpleTime(time) {
      if (!time) return '';
      
      const beijingTime = moment(time).tz('Asia/Shanghai');
      const today = moment().tz('Asia/Shanghai').format('YYYY-MM-DD');
      const timeDate = beijingTime.format('YYYY-MM-DD');
      
      if (timeDate === today) {
        return beijingTime.format('HH:mm');
      } else {
        return beijingTime.format('MM-DD HH:mm');
      }
    },

    /**
     * 格式化相对时间
     */
    formatRelativeTime(time) {
      if (!time) return '';
      
      const beijingTime = moment(time).tz('Asia/Shanghai');
      const now = moment().tz('Asia/Shanghai');
      
      const diffMinutes = now.diff(beijingTime, 'minutes');
      
      if (diffMinutes < 1) {
        return '刚刚';
      } else if (diffMinutes < 60) {
        return `${diffMinutes}分钟前`;
      } else if (diffMinutes < 1440) { // 24小时
        const diffHours = Math.floor(diffMinutes / 60);
        return `${diffHours}小时前`;
      } else {
        return beijingTime.format('MM-DD HH:mm');
      }
    }
  }
}
</script>
```

#### 2.3 React时间处理Hook
```javascript
import { useState, useEffect } from 'react';
import moment from 'moment-timezone';

// 时间处理Hook
export const useTimeFormat = (utcTime, format = 'YYYY-MM-DD HH:mm:ss') => {
  const [formattedTime, setFormattedTime] = useState('');

  useEffect(() => {
    if (!utcTime) {
      setFormattedTime('');
      return;
    }

    const beijingTime = moment(utcTime).tz('Asia/Shanghai').format(format);
    setFormattedTime(beijingTime);
  }, [utcTime, format]);

  return formattedTime;
};

// 相对时间Hook
export const useRelativeTime = (utcTime) => {
  const [relativeTime, setRelativeTime] = useState('');

  useEffect(() => {
    if (!utcTime) {
      setRelativeTime('');
      return;
    }

    const beijingTime = moment(utcTime).tz('Asia/Shanghai');
    const now = moment().tz('Asia/Shanghai');
    
    const diffMinutes = now.diff(beijingTime, 'minutes');
    
    if (diffMinutes < 1) {
      setRelativeTime('刚刚');
    } else if (diffMinutes < 60) {
      setRelativeTime(`${diffMinutes}分钟前`);
    } else if (diffMinutes < 1440) {
      const diffHours = Math.floor(diffMinutes / 60);
      setRelativeTime(`${diffHours}小时前`);
    } else {
      setRelativeTime(beijingTime.format('MM-DD HH:mm'));
    }
  }, [utcTime]);

  return relativeTime;
};

// React组件示例
export const TimeDisplay = ({ utcTime, type = 'full' }) => {
  const fullTime = useTimeFormat(utcTime);
  const relativeTime = useRelativeTime(utcTime);

  const getDisplayTime = () => {
    switch (type) {
      case 'full':
        return fullTime;
      case 'relative':
        return relativeTime;
      case 'simple':
        if (!utcTime) return '';
        const beijingTime = moment(utcTime).tz('Asia/Shanghai');
        const today = moment().tz('Asia/Shanghai').format('YYYY-MM-DD');
        const timeDate = beijingTime.format('YYYY-MM-DD');
        
        if (timeDate === today) {
          return beijingTime.format('HH:mm');
        } else {
          return beijingTime.format('MM-DD HH:mm');
        }
      default:
        return fullTime;
    }
  };

  return <span>{getDisplayTime()}</span>;
};
```

### 3. 前端时间显示最佳实践

#### 3.1 时间显示规则
```javascript
// 时间显示规则配置
const TIME_DISPLAY_RULES = {
  // 今天的时间：只显示时分
  today: {
    format: 'HH:mm',
    prefix: '今天'
  },
  
  // 昨天的时间：显示日期+时分
  yesterday: {
    format: 'MM-DD HH:mm',
    prefix: '昨天'
  },
  
  // 本周的时间：显示星期+时分
  thisWeek: {
    format: 'dddd HH:mm',
    prefix: ''
  },
  
  // 其他时间：显示完整日期时间
  other: {
    format: 'YYYY-MM-DD HH:mm',
    prefix: ''
  }
};

// 智能时间显示函数
function getSmartTimeDisplay(utcTime) {
  if (!utcTime) return '';
  
  const moment = require('moment-timezone');
  const beijingTime = moment(utcTime).tz('Asia/Shanghai');
  const now = moment().tz('Asia/Shanghai');
  
  const diffDays = now.diff(beijingTime, 'days');
  
  if (diffDays === 0) {
    // 今天
    return `今天 ${beijingTime.format('HH:mm')}`;
  } else if (diffDays === 1) {
    // 昨天
    return `昨天 ${beijingTime.format('HH:mm')}`;
  } else if (diffDays < 7) {
    // 本周
    return beijingTime.format('dddd HH:mm');
  } else {
    // 其他
    return beijingTime.format('YYYY-MM-DD HH:mm');
  }
}
```

#### 3.2 时间格式化组件
```javascript
// 通用时间格式化组件
export const TimeFormatter = {
  // 报餐时间显示
  formatMealTime: (utcTime) => {
    if (!utcTime) return '';
    const moment = require('moment-timezone');
    return moment(utcTime).tz('Asia/Shanghai').format('MM-DD HH:mm');
  },

  // 扫码时间显示
  formatScanTime: (utcTime) => {
    if (!utcTime) return '';
    const moment = require('moment-timezone');
    const beijingTime = moment(utcTime).tz('Asia/Shanghai');
    const today = moment().tz('Asia/Shanghai').format('YYYY-MM-DD');
    const timeDate = beijingTime.format('YYYY-MM-DD');
    
    if (timeDate === today) {
      return `今天 ${beijingTime.format('HH:mm')}`;
    } else {
      return beijingTime.format('MM-DD HH:mm');
    }
  },

  // 创建时间显示
  formatCreateTime: (utcTime) => {
    if (!utcTime) return '';
    const moment = require('moment-timezone');
    return moment(utcTime).tz('Asia/Shanghai').format('YYYY-MM-DD HH:mm:ss');
  },

  // 相对时间显示
  formatRelativeTime: (utcTime) => {
    if (!utcTime) return '';
    const moment = require('moment-timezone');
    const beijingTime = moment(utcTime).tz('Asia/Shanghai');
    const now = moment().tz('Asia/Shanghai');
    
    const diffMinutes = now.diff(beijingTime, 'minutes');
    
    if (diffMinutes < 1) return '刚刚';
    if (diffMinutes < 60) return `${diffMinutes}分钟前`;
    if (diffMinutes < 1440) return `${Math.floor(diffMinutes / 60)}小时前`;
    if (diffMinutes < 10080) return `${Math.floor(diffMinutes / 1440)}天前`;
    
    return beijingTime.format('YYYY-MM-DD');
  }
};
```

## 📱 移动端时间显示

### 1. 移动端时间显示优化
```javascript
// 移动端时间显示配置
const MOBILE_TIME_CONFIG = {
  // 列表页时间显示：简化格式
  list: {
    today: 'HH:mm',
    yesterday: '昨天 HH:mm',
    thisWeek: 'dddd HH:mm',
    other: 'MM-DD HH:mm'
  },
  
  // 详情页时间显示：完整格式
  detail: {
    format: 'YYYY年MM月DD日 HH:mm:ss'
  },
  
  // 卡片时间显示：紧凑格式
  card: {
    format: 'MM-DD HH:mm'
  }
};

// 移动端时间显示函数
function getMobileTimeDisplay(utcTime, context = 'list') {
  if (!utcTime) return '';
  
  const moment = require('moment-timezone');
  const beijingTime = moment(utcTime).tz('Asia/Shanghai');
  const now = moment().tz('Asia/Shanghai');
  
  const diffDays = now.diff(beijingTime, 'days');
  const config = MOBILE_TIME_CONFIG[context];
  
  if (diffDays === 0) {
    return beijingTime.format(config.today);
  } else if (diffDays === 1) {
    return beijingTime.format(config.yesterday);
  } else if (diffDays < 7) {
    return beijingTime.format(config.thisWeek);
  } else {
    return beijingTime.format(config.other);
  }
}
```

## ⚠️ 注意事项

### 1. 时区处理注意事项
- **不要在前端进行时区转换**: 后端已返回北京时间，前端直接显示即可
- **避免使用new Date()**: 使用moment-timezone库处理时间
- **统一时间格式**: 所有时间显示使用统一格式

### 2. 性能优化建议
- **时间格式化缓存**: 对相同时间进行缓存，避免重复计算
- **按需加载**: 只在需要时加载moment-timezone库
- **时间组件复用**: 创建可复用的时间显示组件

### 3. 错误处理
- **空值处理**: 所有时间字段都可能为空，需要做好空值处理
- **格式验证**: 验证时间格式是否正确
- **降级处理**: 当时间转换失败时，显示原始时间

## 📋 依赖包安装

### 1. npm安装
```bash
npm install moment-timezone
```

### 2. yarn安装
```bash
yarn add moment-timezone
```

### 3. CDN引入
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.5.43/moment-timezone-with-data.min.js"></script>
```

## 🔄 更新日志

### v1.0.0 (2024-01-15)
- 初始版本发布
- 统一时区处理标准
- 提供完整的前端时间处理方案
- 包含Vue、React、原生JavaScript示例

## 📞 技术支持

如有问题，请联系技术支持团队：
- 邮箱: support@example.com
- 电话: 400-123-4567
- 微信: tech_support











