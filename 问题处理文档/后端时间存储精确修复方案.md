# åç«¯æ—¶é—´å­˜å‚¨ç²¾ç¡®ä¿®å¤æ–¹æ¡ˆ

## ğŸ¯ é—®é¢˜æ ¹æºåˆ†æ

### å‰ç«¯å‘é€çš„æ•°æ®æ ¼å¼
```javascript
{
  "date": "2025-09-11",           // ç”¨é¤æ—¥æœŸï¼ˆå­—ç¬¦ä¸²ï¼‰
  "mealType": "dinner",           // é¤æ¬¡ç±»å‹
  "memberIds": ["user1"],         // æˆå‘˜IDåˆ—è¡¨
  "remark": ""                    // å¤‡æ³¨
}
```

**å…³é”®å‘ç°**ï¼šå‰ç«¯åªå‘é€æ—¥æœŸå­—ç¬¦ä¸²ï¼Œæ²¡æœ‰å‘é€å…·ä½“çš„æ—¶é—´æˆ³ï¼

### åç«¯å¤„ç†æµç¨‹
1. **æ¥æ”¶è¯·æ±‚**ï¼šè·å– `date: "2025-09-11"`
2. **ç”Ÿæˆæ—¶é—´**ï¼šä½¿ç”¨æœåŠ¡å™¨å½“å‰æ—¶é—´ä½œä¸º `registerTime`
3. **å­˜å‚¨é”™è¯¯**ï¼šé”™è¯¯åœ°å°†æœåŠ¡å™¨æœ¬åœ°æ—¶é—´å­˜å‚¨ä¸ºUTCæ—¶é—´

### é—®é¢˜ç¤ºä¾‹
- **ç”¨æˆ·æŠ¥é¤æ—¶é—´**ï¼š17:18ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰
- **æœåŠ¡å™¨æ—¶é—´**ï¼š17:18ï¼ˆæœ¬åœ°æ—¶é—´ï¼‰
- **é”™è¯¯å­˜å‚¨**ï¼š`2025-09-11T17:18:00.000Z`ï¼ˆå½“ä½œUTCæ—¶é—´ï¼‰
- **æ­£ç¡®å­˜å‚¨**ï¼š`2025-09-11T09:18:00.000Z`ï¼ˆçœŸæ­£çš„UTCæ—¶é—´ï¼‰

## ğŸ› ï¸ ç²¾ç¡®ä¿®å¤æ–¹æ¡ˆ

### 1. ä¿®å¤æŠ¥é¤æœåŠ¡æ ¸å¿ƒé€»è¾‘

#### 1.1 ä¿®å¤ `services/diningService.js`

```javascript
// ä¿®å¤å‰çš„é—®é¢˜ä»£ç 
async submitDeptOrder(userId, date, mealType, memberIds, remark, db) {
  try {
    // 1. éªŒè¯æŠ¥é¤æ—¥æœŸï¼ˆä¸èƒ½æ˜¯è¿‡å»çš„æ—¥æœŸï¼‰
    const today = moment().tz('Asia/Shanghai').format('YYYY-MM-DD');
    if (moment(date).isBefore(today)) {
      throw new Error('ä¸èƒ½ä¸ºè¿‡å»çš„æ—¥æœŸæŠ¥é¤');
    }
    
    // ... å…¶ä»–éªŒè¯é€»è¾‘
    
    // åˆ›å»ºè®¢å•æ—¶æ²¡æœ‰æ­£ç¡®å¤„ç†æ—¶é—´
    await db.execute(
      `INSERT INTO dining_orders 
       (_id, deptId, deptName, registrantId, userId, userName, memberIds, memberNames, memberCount, 
        diningDate, mealType, status, diningStatus, remark, createTime, updateTime)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', 'ordered', ?, NOW(), NOW())`,
      [/* å‚æ•°åˆ—è¡¨ */]
    );
  }
}

// ä¿®å¤åçš„æ­£ç¡®ä»£ç 
async submitDeptOrder(userId, date, mealType, memberIds, remark, db) {
  try {
    // 1. éªŒè¯æŠ¥é¤æ—¥æœŸï¼ˆä¸èƒ½æ˜¯è¿‡å»çš„æ—¥æœŸï¼‰
    const today = moment().tz('Asia/Shanghai').format('YYYY-MM-DD');
    if (moment(date).isBefore(today)) {
      throw new Error('ä¸èƒ½ä¸ºè¿‡å»çš„æ—¥æœŸæŠ¥é¤');
    }
    
    // ... å…¶ä»–éªŒè¯é€»è¾‘
    
    // 2. æ­£ç¡®å¤„ç†æŠ¥é¤æ—¶é—´
    const now = moment().tz('Asia/Shanghai'); // è·å–å½“å‰åŒ—äº¬æ—¶é—´
    const utcNow = now.utc().toDate(); // è½¬æ¢ä¸ºUTCæ—¶é—´ç”¨äºå­˜å‚¨
    
    // 3. åˆ›å»ºè®¢å•æ—¶ä½¿ç”¨æ­£ç¡®çš„æ—¶é—´
    await db.execute(
      `INSERT INTO dining_orders 
       (_id, deptId, deptName, registrantId, userId, userName, memberIds, memberNames, memberCount, 
        diningDate, mealType, status, diningStatus, remark, registerTime, createTime, updateTime)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', 'ordered', ?, ?, ?, NOW())`,
      [
        orderId,
        registrant.departmentId,
        registrant.department,
        userId,
        userId,
        registrant.nickName,
        JSON.stringify(memberIds),
        JSON.stringify(memberNames),
        memberIds.length,
        date,
        mealType,
        remark || '',
        utcNow, // âœ… æ­£ç¡®çš„UTCæ—¶é—´
        utcNow, // âœ… æ­£ç¡®çš„UTCæ—¶é—´
        utcNow  // âœ… æ­£ç¡®çš„UTCæ—¶é—´
      ]
    );
  }
}
```

#### 1.2 ä¿®å¤ `services/diningServiceEnhanced.js`

```javascript
// ä¿®å¤åçš„ INSERT è¯­å¥
INSERT INTO dining_orders (
  _id, menuId, deptId, deptName, registrantId, registrantName,
  userId, userName, memberIds, memberNames, memberCount, 
  diningDate, mealType, status, diningStatus, totalAmount, 
  remark, registerTime, createTime, updateTime
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())

// ä¿®å¤åçš„å‚æ•°æ˜ å°„
const now = moment().tz('Asia/Shanghai'); // åŒ—äº¬æ—¶é—´
const utcNow = now.utc().toDate(); // UTCæ—¶é—´å­˜å‚¨

[
  orderId,
  menu._id,
  adminInfo.departmentId,
  adminInfo.departmentName,
  adminUserId,           // registrantId
  adminInfo.nickName,    // registrantName
  adminUserId,           // userId âœ… æ–°å¢
  adminInfo.nickName,    // userName âœ… æ–°å¢
  JSON.stringify(memberIds),
  JSON.stringify(memberNames),
  memberIds.length,
  orderData.date,
  orderData.mealType,
  'confirmed',
  'ordered',             // diningStatus âœ… æ–°å¢
  totalAmount,
  orderData.remark || '',
  utcNow,                // registerTime âœ… æ­£ç¡®çš„UTCæ—¶é—´
  utcNow                 // createTime âœ… æ­£ç¡®çš„UTCæ—¶é—´
]
```

### 2. ä¿®å¤ç¡®è®¤å°±é¤æœåŠ¡

#### 2.1 ä¿®å¤ `services/diningConfirmationService.js`

```javascript
// ä¿®å¤å‰çš„é—®é¢˜ä»£ç 
const moment = require('moment'); // âŒ æ²¡æœ‰æ—¶åŒºæ”¯æŒ

async confirmDiningManually(userId, orderId, confirmationType = 'manual', db) {
  // ...
  const now = moment(); // âŒ æœåŠ¡å™¨æœ¬åœ°æ—¶é—´
  const actualDiningTime = now.format('YYYY-MM-DD HH:mm:ss'); // âŒ æœ¬åœ°æ—¶é—´æ ¼å¼
  
  await connection.execute(
    `UPDATE dining_orders 
     SET diningStatus = 'dined', 
         actualDiningTime = ?,
         updateTime = NOW()
     WHERE _id = ?`,
    [actualDiningTime, orderId] // âŒ å­˜å‚¨æœ¬åœ°æ—¶é—´
  );
}

// ä¿®å¤åçš„æ­£ç¡®ä»£ç 
const moment = require('moment-timezone'); // âœ… ä½¿ç”¨æ”¯æŒæ—¶åŒºçš„moment

async confirmDiningManually(userId, orderId, confirmationType = 'manual', db) {
  // ...
  const now = moment().tz('Asia/Shanghai'); // âœ… åŒ—äº¬æ—¶é—´
  const utcNow = now.utc().toDate(); // âœ… è½¬æ¢ä¸ºUTCæ—¶é—´å­˜å‚¨
  
  await connection.execute(
    `UPDATE dining_orders 
     SET diningStatus = 'dined', 
         actualDiningTime = ?,
         updateTime = NOW()
     WHERE _id = ?`,
    [utcNow, orderId] // âœ… å­˜å‚¨UTCæ—¶é—´
  );
}
```

### 3. ä¿®å¤æ‰«ç æœåŠ¡

#### 3.1 ç¡®ä¿ `services/qrScanService.js` ä½¿ç”¨æ­£ç¡®çš„æ—¶é—´å¤„ç†

```javascript
// ç¡®ä¿æ‰«ç æœåŠ¡ä½¿ç”¨æ­£ç¡®çš„æ—¶åŒºå¤„ç†
async processQRScan(userId, qrCode, scanTime, db) {
  // ...
  
  // 2. æ ¹æ®æ‰«ç æ—¶é—´åˆ¤æ–­é¤æ¬¡ï¼ˆä½¿ç”¨åŒ—äº¬æ—¶é—´ï¼‰
  const beijingScanTime = moment(scanTime).tz('Asia/Shanghai');
  const mealType = this.getMealTypeByTime(beijingScanTime.toDate());
  
  // ä½¿ç”¨åŒ—äº¬æ—¶é—´çš„æ—¥æœŸ
  const diningDate = beijingScanTime.format('YYYY-MM-DD');
  
  // 6. åˆ›å»ºå°±é¤ç™»è®°è®°å½•
  const registrationId = uuidv4();
  // âœ… å­˜å‚¨UTCæ—¶é—´åˆ°æ•°æ®åº“
  const utcScanTime = moment(scanTime).utc().toDate();
  
  await connection.execute(`
    INSERT INTO dining_registrations 
    (_id, userId, userName, qrCodeId, qrCode, scanTime, mealType, diningDate, orderId, status)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'success')
  `, [
    registrationId,
    userId,
    userInfo.nickName,
    qrCodeInfo._id,
    qrCode,
    utcScanTime,  // âœ… å­˜å‚¨UTCæ—¶é—´
    mealType,
    diningDate,
    orderInfo._id
  ]);
}
```

### 4. å†å²æ•°æ®ä¿®å¤è„šæœ¬

#### 4.1 ç²¾ç¡®çš„æ•°æ®ä¿®å¤è„šæœ¬

```javascript
// fix_historical_time_data_precise.js
const mysql = require('mysql2/promise');
const moment = require('moment-timezone');

async function fixHistoricalTimeDataPrecise() {
  let connection;
  try {
    connection = await mysql.createConnection({
      host: process.env.DB_HOST || 'localhost',
      user: process.env.DB_USER || 'root',
      password: process.env.DB_PASSWORD || '',
      database: process.env.DB_NAME || 'dining_system',
      timezone: '+00:00'
    });

    console.log('ğŸ”§ å¼€å§‹ç²¾ç¡®ä¿®å¤å†å²æ—¶é—´æ•°æ®...');
    console.log('âš ï¸  è¯·ç¡®ä¿å·²å¤‡ä»½æ•°æ®åº“ï¼');

    // 1. ä¿®å¤æŠ¥é¤è®¢å•æ—¶é—´
    await fixDiningOrdersTimePrecise(connection);
    
    // 2. ä¿®å¤ç¡®è®¤å°±é¤æ—¶é—´
    await fixDiningConfirmationsTimePrecise(connection);
    
    // 3. ä¿®å¤æ‰«ç ç™»è®°æ—¶é—´
    await fixDiningRegistrationsTimePrecise(connection);

    console.log('âœ… å†å²æ—¶é—´æ•°æ®ç²¾ç¡®ä¿®å¤å®Œæˆï¼');
  } catch (error) {
    console.error('âŒ ä¿®å¤å†å²æ—¶é—´æ•°æ®å¤±è´¥:', error);
  } finally {
    if (connection) {
      await connection.end();
    }
  }
}

/**
 * ç²¾ç¡®ä¿®å¤æŠ¥é¤è®¢å•æ—¶é—´
 * è¯†åˆ«é”™è¯¯å­˜å‚¨çš„æœ¬åœ°æ—¶é—´ï¼ˆä½œä¸ºUTCï¼‰å¹¶ä¿®æ­£
 */
async function fixDiningOrdersTimePrecise(connection) {
  try {
    console.log('\nğŸ“‹ ç²¾ç¡®ä¿®å¤æŠ¥é¤è®¢å•æ—¶é—´...');
    
    // æŸ¥æ‰¾éœ€è¦ä¿®å¤çš„è®¢å•
    // æ¡ä»¶ï¼šæ—¶é—´çœ‹èµ·æ¥åƒæœ¬åœ°æ—¶é—´ä½†å­˜å‚¨ä¸ºUTCçš„
    const [orders] = await connection.execute(`
      SELECT _id, registerTime, createTime, diningDate, mealType
      FROM dining_orders 
      WHERE registerTime IS NOT NULL 
      AND registerTime LIKE '%T0%:00.000Z'
      AND HOUR(registerTime) BETWEEN 6 AND 23
      AND registerTime NOT LIKE '%T00:%'
      AND registerTime NOT LIKE '%T01:%'
      AND registerTime NOT LIKE '%T02:%'
      AND registerTime NOT LIKE '%T03:%'
      AND registerTime NOT LIKE '%T04:%'
      AND registerTime NOT LIKE '%T05:%'
    `);

    console.log(`ğŸ” æ‰¾åˆ° ${orders.length} ä¸ªéœ€è¦ç²¾ç¡®ä¿®å¤çš„æŠ¥é¤è®¢å•`);

    if (orders.length === 0) {
      console.log('âœ… æ²¡æœ‰éœ€è¦ä¿®å¤çš„æŠ¥é¤è®¢å•');
      return;
    }

    let fixedCount = 0;
    for (const order of orders) {
      try {
        // åˆ†ææ—¶é—´æ¨¡å¼
        const wrongTime = new Date(order.registerTime);
        const hour = wrongTime.getUTCHours();
        
        // å¦‚æœUTCå°æ—¶åœ¨6-23ä¹‹é—´ï¼Œè¯´æ˜è¿™æ˜¯é”™è¯¯çš„æœ¬åœ°æ—¶é—´å­˜å‚¨
        if (hour >= 6 && hour <= 23) {
          // å°†é”™è¯¯çš„UTCæ—¶é—´å‡å»8å°æ—¶ï¼ˆåŒ—äº¬æ—¶é—´æ¯”UTCå¿«8å°æ—¶ï¼‰
          const correctTime = moment(wrongTime).subtract(8, 'hours').utc().toDate();
          
          await connection.execute(
            `UPDATE dining_orders 
             SET registerTime = ?, createTime = ?
             WHERE _id = ?`,
            [correctTime.toISOString(), correctTime.toISOString(), order._id]
          );
          
          console.log(`âœ… ä¿®å¤è®¢å• ${order._id}: ${order.registerTime} -> ${correctTime.toISOString()}`);
          fixedCount++;
        }
      } catch (error) {
        console.error(`âŒ ä¿®å¤è®¢å• ${order._id} å¤±è´¥:`, error.message);
      }
    }

    console.log(`ğŸ“Š æŠ¥é¤è®¢å•ç²¾ç¡®ä¿®å¤å®Œæˆ: ${fixedCount}/${orders.length}`);
  } catch (error) {
    console.error('âŒ ä¿®å¤æŠ¥é¤è®¢å•æ—¶é—´å¤±è´¥:', error);
  }
}

/**
 * ç²¾ç¡®ä¿®å¤ç¡®è®¤å°±é¤æ—¶é—´
 */
async function fixDiningConfirmationsTimePrecise(connection) {
  try {
    console.log('\nğŸ½ï¸ ç²¾ç¡®ä¿®å¤ç¡®è®¤å°±é¤æ—¶é—´...');
    
    const [confirmations] = await connection.execute(`
      SELECT _id, actualDiningTime, diningDate, mealType
      FROM dining_orders 
      WHERE actualDiningTime IS NOT NULL 
      AND actualDiningTime LIKE '%T0%:00.000Z'
      AND HOUR(actualDiningTime) BETWEEN 6 AND 23
      AND actualDiningTime NOT LIKE '%T00:%'
      AND actualDiningTime NOT LIKE '%T01:%'
      AND actualDiningTime NOT LIKE '%T02:%'
      AND actualDiningTime NOT LIKE '%T03:%'
      AND actualDiningTime NOT LIKE '%T04:%'
      AND actualDiningTime NOT LIKE '%T05:%'
    `);

    console.log(`ğŸ” æ‰¾åˆ° ${confirmations.length} ä¸ªéœ€è¦ç²¾ç¡®ä¿®å¤çš„ç¡®è®¤å°±é¤è®°å½•`);

    if (confirmations.length === 0) {
      console.log('âœ… æ²¡æœ‰éœ€è¦ä¿®å¤çš„ç¡®è®¤å°±é¤è®°å½•');
      return;
    }

    let fixedCount = 0;
    for (const confirmation of confirmations) {
      try {
        const wrongTime = new Date(confirmation.actualDiningTime);
        const hour = wrongTime.getUTCHours();
        
        if (hour >= 6 && hour <= 23) {
          const correctTime = moment(wrongTime).subtract(8, 'hours').utc().toDate();
          
          await connection.execute(
            `UPDATE dining_orders 
             SET actualDiningTime = ?
             WHERE _id = ?`,
            [correctTime.toISOString(), confirmation._id]
          );
          
          console.log(`âœ… ä¿®å¤ç¡®è®¤å°±é¤ ${confirmation._id}: ${confirmation.actualDiningTime} -> ${correctTime.toISOString()}`);
          fixedCount++;
        }
      } catch (error) {
        console.error(`âŒ ä¿®å¤ç¡®è®¤å°±é¤ ${confirmation._id} å¤±è´¥:`, error.message);
      }
    }

    console.log(`ğŸ“Š ç¡®è®¤å°±é¤ç²¾ç¡®ä¿®å¤å®Œæˆ: ${fixedCount}/${confirmations.length}`);
  } catch (error) {
    console.error('âŒ ä¿®å¤ç¡®è®¤å°±é¤æ—¶é—´å¤±è´¥:', error);
  }
}

/**
 * ç²¾ç¡®ä¿®å¤æ‰«ç ç™»è®°æ—¶é—´
 */
async function fixDiningRegistrationsTimePrecise(connection) {
  try {
    console.log('\nğŸ“± ç²¾ç¡®ä¿®å¤æ‰«ç ç™»è®°æ—¶é—´...');
    
    const [registrations] = await connection.execute(`
      SELECT _id, scanTime, diningDate, mealType
      FROM dining_registrations 
      WHERE scanTime IS NOT NULL 
      AND scanTime LIKE '%T0%:00.000Z'
      AND HOUR(scanTime) BETWEEN 6 AND 23
      AND scanTime NOT LIKE '%T00:%'
      AND scanTime NOT LIKE '%T01:%'
      AND scanTime NOT LIKE '%T02:%'
      AND scanTime NOT LIKE '%T03:%'
      AND scanTime NOT LIKE '%T04:%'
      AND scanTime NOT LIKE '%T05:%'
    `);

    console.log(`ğŸ” æ‰¾åˆ° ${registrations.length} ä¸ªéœ€è¦ç²¾ç¡®ä¿®å¤çš„æ‰«ç ç™»è®°è®°å½•`);

    if (registrations.length === 0) {
      console.log('âœ… æ²¡æœ‰éœ€è¦ä¿®å¤çš„æ‰«ç ç™»è®°è®°å½•');
      return;
    }

    let fixedCount = 0;
    for (const registration of registrations) {
      try {
        const wrongTime = new Date(registration.scanTime);
        const hour = wrongTime.getUTCHours();
        
        if (hour >= 6 && hour <= 23) {
          const correctTime = moment(wrongTime).subtract(8, 'hours').utc().toDate();
          
          await connection.execute(
            `UPDATE dining_registrations 
             SET scanTime = ?
             WHERE _id = ?`,
            [correctTime.toISOString(), registration._id]
          );
          
          console.log(`âœ… ä¿®å¤æ‰«ç ç™»è®° ${registration._id}: ${registration.scanTime} -> ${correctTime.toISOString()}`);
          fixedCount++;
        }
      } catch (error) {
        console.error(`âŒ ä¿®å¤æ‰«ç ç™»è®° ${registration._id} å¤±è´¥:`, error.message);
      }
    }

    console.log(`ğŸ“Š æ‰«ç ç™»è®°ç²¾ç¡®ä¿®å¤å®Œæˆ: ${fixedCount}/${registrations.length}`);
  } catch (error) {
    console.error('âŒ ä¿®å¤æ‰«ç ç™»è®°æ—¶é—´å¤±è´¥:', error);
  }
}

// è¿è¡Œç²¾ç¡®ä¿®å¤è„šæœ¬
if (require.main === module) {
  fixHistoricalTimeDataPrecise();
}

module.exports = { 
  fixHistoricalTimeDataPrecise,
  fixDiningOrdersTimePrecise,
  fixDiningConfirmationsTimePrecise,
  fixDiningRegistrationsTimePrecise
};
```

### 5. éªŒè¯ä¿®å¤æ•ˆæœ

#### 5.1 åˆ›å»ºéªŒè¯æµ‹è¯•è„šæœ¬

```javascript
// test_time_fix_precise.js
const moment = require('moment-timezone');

function testTimeFixPrecise() {
  console.log('ğŸ§ª ç²¾ç¡®æ—¶é—´ä¿®å¤æ•ˆæœæµ‹è¯•');
  console.log('=====================================');

  // æµ‹è¯•ç”¨ä¾‹ï¼šç”¨æˆ·17:18æŠ¥é¤
  console.log('\nğŸ“‹ æµ‹è¯•ç”¨ä¾‹ï¼šç”¨æˆ·17:18æŠ¥é¤');
  
  const userReportTime = '2025-09-11 17:18:00'; // ç”¨æˆ·å®é™…æŠ¥é¤æ—¶é—´
  console.log(`ç”¨æˆ·å®é™…æŠ¥é¤æ—¶é—´: ${userReportTime}`);
  
  // ä¿®å¤å‰ï¼šé”™è¯¯å­˜å‚¨
  const wrongStorage = new Date('2025-09-11T17:18:00.000Z'); // é”™è¯¯ï¼šæœ¬åœ°æ—¶é—´å½“ä½œUTC
  console.log(`ä¿®å¤å‰é”™è¯¯å­˜å‚¨: ${wrongStorage.toISOString()}`);
  console.log(`ä¿®å¤å‰å‰ç«¯æ˜¾ç¤º: ${moment(wrongStorage).tz('Asia/Shanghai').format('YYYY-MM-DD HH:mm:ss')}`);
  
  // ä¿®å¤åï¼šæ­£ç¡®å­˜å‚¨
  const correctStorage = moment.tz(userReportTime, 'Asia/Shanghai').utc().toDate();
  console.log(`ä¿®å¤åæ­£ç¡®å­˜å‚¨: ${correctStorage.toISOString()}`);
  console.log(`ä¿®å¤åå‰ç«¯æ˜¾ç¤º: ${moment(correctStorage).tz('Asia/Shanghai').format('YYYY-MM-DD HH:mm:ss')}`);
  
  // éªŒè¯ä¿®å¤æ•ˆæœ
  const originalHour = moment(userReportTime).hour();
  const wrongDisplayHour = moment(wrongStorage).tz('Asia/Shanghai').hour();
  const correctDisplayHour = moment(correctStorage).tz('Asia/Shanghai').hour();
  
  console.log('\nğŸ“Š ä¿®å¤æ•ˆæœå¯¹æ¯”:');
  console.log(`åŸå§‹æ—¶é—´å°æ—¶: ${originalHour}`);
  console.log(`ä¿®å¤å‰æ˜¾ç¤ºå°æ—¶: ${wrongDisplayHour} (é”™è¯¯: ç›¸å·®${originalHour - wrongDisplayHour}å°æ—¶)`);
  console.log(`ä¿®å¤åæ˜¾ç¤ºå°æ—¶: ${correctDisplayHour} (æ­£ç¡®: å®Œå…¨ä¸€è‡´)`);
  
  if (correctDisplayHour === originalHour) {
    console.log('âœ… ç²¾ç¡®ä¿®å¤æˆåŠŸï¼æ—¶é—´æ˜¾ç¤ºæ­£ç¡®');
  } else {
    console.log('âŒ ç²¾ç¡®ä¿®å¤å¤±è´¥ï¼æ—¶é—´æ˜¾ç¤ºä»æœ‰é—®é¢˜');
  }
}

// è¿è¡Œæµ‹è¯•
if (require.main === module) {
  testTimeFixPrecise();
}

module.exports = { testTimeFixPrecise };
```

## ğŸ“‹ ä¿®å¤æ­¥éª¤

### ç¬¬ä¸€æ­¥ï¼šå®‰è£…ä¾èµ–
```bash
npm install moment-timezone
```

### ç¬¬äºŒæ­¥ï¼šä¿®å¤ä»£ç æ–‡ä»¶
1. **ä¿®å¤ `services/diningService.js`**
2. **ä¿®å¤ `services/diningServiceEnhanced.js`**
3. **ä¿®å¤ `services/diningConfirmationService.js`**
4. **ç¡®ä¿ `services/qrScanService.js` ä½¿ç”¨æ­£ç¡®çš„æ—¶åŒºå¤„ç†**

### ç¬¬ä¸‰æ­¥ï¼šè¿è¡Œç²¾ç¡®ä¿®å¤è„šæœ¬
```bash
# è®¾ç½®ç¯å¢ƒå˜é‡
export DB_HOST=localhost
export DB_USER=root
export DB_PASSWORD=your_password
export DB_NAME=dining_system

# è¿è¡Œç²¾ç¡®ä¿®å¤è„šæœ¬
node fix_historical_time_data_precise.js
```

### ç¬¬å››æ­¥ï¼šéªŒè¯ä¿®å¤æ•ˆæœ
```bash
# è¿è¡ŒéªŒè¯æµ‹è¯•
node test_time_fix_precise.js
```

## ğŸ¯ ä¿®å¤æ•ˆæœé¢„æœŸ

### ä¿®å¤å‰
- ç”¨æˆ·17:18æŠ¥é¤
- å­˜å‚¨ä¸º `2025-09-11T17:18:00.000Z`ï¼ˆé”™è¯¯ï¼‰
- å‰ç«¯æ˜¾ç¤º09:18ï¼ˆé”™è¯¯ï¼‰

### ä¿®å¤å
- ç”¨æˆ·17:18æŠ¥é¤
- å­˜å‚¨ä¸º `2025-09-11T09:18:00.000Z`ï¼ˆæ­£ç¡®ï¼‰
- å‰ç«¯æ˜¾ç¤º17:18ï¼ˆæ­£ç¡®ï¼‰

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **å¤‡ä»½æ•°æ®**ï¼šä¿®å¤å‰å¿…é¡»å¤‡ä»½æ•°æ®åº“
2. **æµ‹è¯•ç¯å¢ƒ**ï¼šå»ºè®®å…ˆåœ¨æµ‹è¯•ç¯å¢ƒéªŒè¯
3. **é€æ­¥éƒ¨ç½²**ï¼šå¯ä»¥åˆ†æ­¥éª¤éƒ¨ç½²ä¿®å¤
4. **ç›‘æ§å‘Šè­¦**ï¼šä¿®å¤åéœ€è¦ç›‘æ§æ—¶é—´ç›¸å…³åŠŸèƒ½
5. **ç²¾ç¡®è¯†åˆ«**ï¼šä¿®å¤è„šæœ¬ä¼šç²¾ç¡®è¯†åˆ«éœ€è¦ä¿®å¤çš„è®°å½•ï¼Œé¿å…è¯¯ä¿®å¤

## ğŸ“ æ€»ç»“

è¿™ä¸ªç²¾ç¡®ä¿®å¤æ–¹æ¡ˆè§£å†³äº†å‰ç«¯åˆ†æä¸­æåˆ°çš„æ ¸å¿ƒé—®é¢˜ï¼š

1. **é—®é¢˜è¯†åˆ«**ï¼šå‰ç«¯åªå‘é€æ—¥æœŸå­—ç¬¦ä¸²ï¼Œåç«¯ä½¿ç”¨æœåŠ¡å™¨æ—¶é—´
2. **æ—¶åŒºå¤„ç†**ï¼šæ­£ç¡®å°†åŒ—äº¬æ—¶é—´è½¬æ¢ä¸ºUTCæ—¶é—´å­˜å‚¨
3. **å†å²æ•°æ®**ï¼šç²¾ç¡®è¯†åˆ«å’Œä¿®å¤é”™è¯¯çš„æ—¶é—´è®°å½•
4. **éªŒè¯æœºåˆ¶**ï¼šæä¾›å®Œæ•´çš„æµ‹è¯•å’ŒéªŒè¯æ–¹æ¡ˆ

ä¿®å¤å®Œæˆåï¼ŒæŠ¥é¤æ—¶é—´å°†æ­£ç¡®æ˜¾ç¤ºï¼Œå½»åº•è§£å†³æ—¶é—´ç›¸å·®8å°æ—¶çš„é—®é¢˜ã€‚
