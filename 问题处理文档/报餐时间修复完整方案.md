# 报餐时间修复完整方案

## 🎯 问题分析

### 当前问题现象
- **用户实际报餐时间**：17:18（北京时间）
- **后端存储的UTC时间**：`2025-09-11T01:19:01.000Z`
- **前端显示时间**：09:19（北京时间）

### 问题根源
1. **时区处理不一致**：后端没有正确处理用户本地时间到UTC时间的转换
2. **数据库存储错误**：直接存储用户传入的时间，没有进行时区转换
3. **业务逻辑混乱**：餐次判断基于错误的时间

## 🛠️ 修复方案

### 1. 修复报餐服务时间处理

#### 1.1 修复 `diningService.js` 中的时间处理

```javascript
// 修复前的问题代码
const today = moment().tz('Asia/Shanghai').format('YYYY-MM-DD');
if (moment(date).isBefore(today)) {
  throw new Error('不能为过去的日期报餐');
}

// 修复后的正确代码
const today = moment().tz('Asia/Shanghai').format('YYYY-MM-DD');
if (moment(date).isBefore(today)) {
  throw new Error('不能为过去的日期报餐');
}

// 在创建订单时，添加正确的时间记录
const now = moment().tz('Asia/Shanghai'); // 北京时间
const utcNow = now.utc().toDate(); // 转换为UTC时间存储

await db.execute(
  `INSERT INTO dining_orders 
   (_id, deptId, deptName, registrantId, userId, userName, memberIds, memberNames, memberCount, 
    diningDate, mealType, status, diningStatus, remark, registerTime, createTime, updateTime)
   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', 'ordered', ?, ?, NOW(), NOW())`,
  [
    orderId,
    registrant.departmentId,
    registrant.department,
    userId,
    userId,
    registrant.nickName,
    JSON.stringify(memberIds),
    JSON.stringify(memberNames),
    memberIds.length,
    date,
    mealType,
    remark || '',
    utcNow, // 存储UTC时间
    utcNow  // 存储UTC时间
  ]
);
```

#### 1.2 修复 `diningServiceEnhanced.js` 中的时间处理

```javascript
// 修复后的 INSERT 语句
INSERT INTO dining_orders (
  _id, menuId, deptId, deptName, registrantId, registrantName,
  userId, userName, memberIds, memberNames, memberCount, 
  diningDate, mealType, status, diningStatus, totalAmount, 
  remark, registerTime, createTime, updateTime
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())

// 修复后的参数映射
const now = moment().tz('Asia/Shanghai'); // 北京时间
const utcNow = now.utc().toDate(); // 转换为UTC时间存储

[
  orderId,
  menu._id,
  adminInfo.departmentId,
  adminInfo.departmentName,
  adminUserId,           // registrantId
  adminInfo.nickName,    // registrantName
  adminUserId,           // userId ✅ 新增
  adminInfo.nickName,    // userName ✅ 新增
  JSON.stringify(memberIds),
  JSON.stringify(memberNames),
  memberIds.length,
  orderData.date,
  orderData.mealType,
  'confirmed',
  'ordered',             // diningStatus ✅ 新增
  totalAmount,
  orderData.remark || '',
  utcNow,                // registerTime ✅ 新增
  utcNow                 // createTime ✅ 新增
]
```

### 2. 修复确认就餐服务时间处理

#### 2.1 修复 `diningConfirmationService.js` 中的时区处理

```javascript
// 修复前的问题代码
const moment = require('moment'); // ❌ 没有时区支持

// 修复后的正确代码
const moment = require('moment-timezone'); // ✅ 使用支持时区的moment

// 修复时间检查逻辑
const diningDate = moment(order.diningDate).tz('Asia/Shanghai');
const now = moment().tz('Asia/Shanghai');  // ✅ 使用北京时间

// 修复时间记录逻辑
const actualDiningTime = now.format('YYYY-MM-DD HH:mm:ss');  // ✅ 北京时间
const utcActualDiningTime = now.utc().toDate(); // ✅ 转换为UTC时间存储

await connection.execute(
  `UPDATE dining_orders 
   SET diningStatus = 'dined', 
       actualDiningTime = ?,
       updateTime = NOW()
   WHERE _id = ?`,
  [utcActualDiningTime, orderId] // ✅ 存储UTC时间
);
```

### 3. 修复扫码服务时间处理

#### 3.1 确保扫码服务使用正确的时区处理

```javascript
// 在 qrScanService.js 中确保正确的时间处理
const beijingScanTime = moment(scanTime).tz('Asia/Shanghai');
const mealType = this.getMealTypeByTime(beijingScanTime.toDate());
const diningDate = beijingScanTime.format('YYYY-MM-DD');

// 存储UTC时间到数据库
const utcScanTime = moment(scanTime).utc().toDate();
await connection.execute(`
  INSERT INTO dining_registrations 
  (_id, userId, userName, qrCodeId, qrCode, scanTime, mealType, diningDate, orderId, status)
  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'success')
`, [
  registrationId,
  userId,
  userInfo.nickName,
  qrCodeInfo._id,
  qrCode,
  utcScanTime,  // ✅ 存储UTC时间
  mealType,
  diningDate,
  orderInfo._id
]);
```

### 4. 历史数据修复脚本

#### 4.1 创建数据修复脚本

```javascript
// fix_historical_time_data.js
const mysql = require('mysql2/promise');
const moment = require('moment-timezone');

async function fixHistoricalTimeData() {
  let connection;
  try {
    // 连接数据库
    connection = await mysql.createConnection({
      host: process.env.DB_HOST || 'localhost',
      user: process.env.DB_USER || 'root',
      password: process.env.DB_PASSWORD || '',
      database: process.env.DB_NAME || 'dining_system',
      timezone: '+00:00' // 确保使用UTC时区
    });

    console.log('开始修复历史时间数据...');

    // 1. 修复报餐订单时间
    await fixDiningOrdersTime(connection);
    
    // 2. 修复确认就餐时间
    await fixDiningConfirmationsTime(connection);
    
    // 3. 修复扫码登记时间
    await fixDiningRegistrationsTime(connection);

    console.log('历史时间数据修复完成！');
  } catch (error) {
    console.error('修复历史时间数据失败:', error);
  } finally {
    if (connection) {
      await connection.end();
    }
  }
}

async function fixDiningOrdersTime(connection) {
  try {
    console.log('修复报餐订单时间...');
    
    // 查找需要修复的订单（时间看起来像本地时间但存储为UTC的）
    const [orders] = await connection.execute(`
      SELECT _id, registerTime, createTime, actualDiningTime
      FROM dining_orders 
      WHERE registerTime IS NOT NULL 
      AND registerTime LIKE '%T0%:00.000Z'
      AND HOUR(registerTime) BETWEEN 6 AND 23
    `);

    console.log(`找到 ${orders.length} 个需要修复的报餐订单`);

    for (const order of orders) {
      // 将错误的UTC时间加上8小时
      const wrongTime = new Date(order.registerTime);
      const correctTime = new Date(wrongTime.getTime() + (8 * 60 * 60 * 1000));
      
      await connection.execute(
        `UPDATE dining_orders 
         SET registerTime = ?, createTime = ?
         WHERE _id = ?`,
        [correctTime.toISOString(), correctTime.toISOString(), order._id]
      );
      
      console.log(`修复订单 ${order._id}: ${order.registerTime} -> ${correctTime.toISOString()}`);
    }
  } catch (error) {
    console.error('修复报餐订单时间失败:', error);
  }
}

async function fixDiningConfirmationsTime(connection) {
  try {
    console.log('修复确认就餐时间...');
    
    const [confirmations] = await connection.execute(`
      SELECT _id, actualDiningTime
      FROM dining_orders 
      WHERE actualDiningTime IS NOT NULL 
      AND actualDiningTime LIKE '%T0%:00.000Z'
      AND HOUR(actualDiningTime) BETWEEN 6 AND 23
    `);

    console.log(`找到 ${confirmations.length} 个需要修复的确认就餐记录`);

    for (const confirmation of confirmations) {
      const wrongTime = new Date(confirmation.actualDiningTime);
      const correctTime = new Date(wrongTime.getTime() + (8 * 60 * 60 * 1000));
      
      await connection.execute(
        `UPDATE dining_orders 
         SET actualDiningTime = ?
         WHERE _id = ?`,
        [correctTime.toISOString(), confirmation._id]
      );
      
      console.log(`修复确认就餐 ${confirmation._id}: ${confirmation.actualDiningTime} -> ${correctTime.toISOString()}`);
    }
  } catch (error) {
    console.error('修复确认就餐时间失败:', error);
  }
}

async function fixDiningRegistrationsTime(connection) {
  try {
    console.log('修复扫码登记时间...');
    
    const [registrations] = await connection.execute(`
      SELECT _id, scanTime
      FROM dining_registrations 
      WHERE scanTime IS NOT NULL 
      AND scanTime LIKE '%T0%:00.000Z'
      AND HOUR(scanTime) BETWEEN 6 AND 23
    `);

    console.log(`找到 ${registrations.length} 个需要修复的扫码登记记录`);

    for (const registration of registrations) {
      const wrongTime = new Date(registration.scanTime);
      const correctTime = new Date(wrongTime.getTime() + (8 * 60 * 60 * 1000));
      
      await connection.execute(
        `UPDATE dining_registrations 
         SET scanTime = ?
         WHERE _id = ?`,
        [correctTime.toISOString(), registration._id]
      );
      
      console.log(`修复扫码登记 ${registration._id}: ${registration.scanTime} -> ${correctTime.toISOString()}`);
    }
  } catch (error) {
    console.error('修复扫码登记时间失败:', error);
  }
}

// 运行修复脚本
if (require.main === module) {
  fixHistoricalTimeData();
}

module.exports = { fixHistoricalTimeData };
```

### 5. 数据库配置优化

#### 5.1 确保数据库时区配置正确

```javascript
// config/database.js
module.exports = {
  development: {
    host: process.env.DB_HOST || 'localhost',
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_NAME || 'dining_system',
    timezone: '+00:00', // 确保数据库使用UTC时区
    charset: 'utf8mb4',
    acquireTimeout: 60000,
    timeout: 60000,
    reconnect: true
  }
};
```

### 6. 时间处理工具类

#### 6.1 创建统一的时间处理工具

```javascript
// utils/timeUtils.js
const moment = require('moment-timezone');

class TimeUtils {
  /**
   * 获取当前北京时间
   * @returns {moment} 北京时间
   */
  static getBeijingTime() {
    return moment().tz('Asia/Shanghai');
  }

  /**
   * 将北京时间转换为UTC时间用于存储
   * @param {Date|moment|string} beijingTime - 北京时间
   * @returns {Date} UTC时间
   */
  static toUTCForStorage(beijingTime) {
    return moment(beijingTime).tz('Asia/Shanghai').utc().toDate();
  }

  /**
   * 将UTC时间转换为北京时间用于显示
   * @param {Date|string} utcTime - UTC时间
   * @returns {string} 北京时间字符串
   */
  static toBeijingForDisplay(utcTime) {
    return moment(utcTime).tz('Asia/Shanghai').format('YYYY-MM-DD HH:mm:ss');
  }

  /**
   * 获取餐次类型
   * @param {Date|moment} time - 时间
   * @returns {string} 餐次类型
   */
  static getMealTypeByTime(time) {
    const beijingTime = moment(time).tz('Asia/Shanghai');
    const hour = beijingTime.hour();
    
    if (hour >= 6 && hour < 10) {
      return 'breakfast';
    } else if (hour >= 11 && hour < 14) {
      return 'lunch';
    } else if (hour >= 17 && hour < 20) {
      return 'dinner';
    }
    return null;
  }

  /**
   * 检查是否在就餐时间内
   * @param {string} mealType - 餐次类型
   * @returns {boolean} 是否在就餐时间内
   */
  static isInDiningTime(mealType) {
    const now = this.getBeijingTime();
    const hour = now.hour();
    
    const mealTimeRanges = {
      'breakfast': { start: 6, end: 10 },
      'lunch': { start: 11, end: 14 },
      'dinner': { start: 17, end: 20 }
    };
    
    const timeRange = mealTimeRanges[mealType];
    return timeRange && hour >= timeRange.start && hour <= timeRange.end;
  }
}

module.exports = TimeUtils;
```

## 📋 修复步骤

### 第一步：立即修复代码
1. **修复报餐服务**：更新 `diningService.js` 和 `diningServiceEnhanced.js`
2. **修复确认就餐服务**：更新 `diningConfirmationService.js`
3. **修复扫码服务**：确保 `qrScanService.js` 使用正确的时区处理
4. **添加时间工具类**：创建 `utils/timeUtils.js`

### 第二步：数据修复
1. **备份数据库**：在修复前备份所有数据
2. **运行修复脚本**：执行 `fix_historical_time_data.js`
3. **验证修复结果**：检查修复后的时间是否正确

### 第三步：测试验证
1. **测试报餐功能**：验证报餐时间存储正确
2. **测试确认就餐功能**：验证确认就餐时间正确
3. **测试扫码功能**：验证扫码时间处理正确
4. **验证前端显示**：确保前端显示时间正确

## ⚠️ 注意事项

1. **备份数据**：修复前必须备份数据库
2. **测试环境**：建议先在测试环境验证修复效果
3. **逐步部署**：可以分步骤部署修复，避免影响生产环境
4. **监控告警**：修复后需要监控时间相关功能是否正常

## 🔧 配置要求

### 1. 依赖包要求
```json
{
  "moment-timezone": "^0.5.43",
  "mysql2": "^3.6.0"
}
```

### 2. 环境变量
```bash
DB_HOST=localhost
DB_USER=root
DB_PASSWORD=your_password
DB_NAME=dining_system
```

### 3. 数据库时区设置
```sql
SET time_zone = '+00:00';
```

## 📊 修复效果预期

修复完成后：
- **报餐时间**：用户17:18报餐，存储为 `2025-09-11T09:18:01.000Z`，前端显示17:18
- **确认就餐时间**：用户18:00确认就餐，存储为 `2025-09-11T10:00:00.000Z`，前端显示18:00
- **扫码时间**：用户12:30扫码，存储为 `2025-09-11T04:30:00.000Z`，前端显示12:30

## 📝 总结

通过以上修复方案，可以彻底解决报餐时间存储和显示的问题：

1. **统一时区处理**：所有时间处理都使用北京时间进行业务逻辑判断
2. **正确存储格式**：数据库统一存储UTC时间
3. **准确显示时间**：前端显示正确的北京时间
4. **历史数据修复**：修复已存在的错误时间数据
5. **预防措施**：通过工具类和规范避免未来出现类似问题

这个修复方案确保了时间处理的一致性和准确性，解决了用户反馈的时间显示错误问题。
