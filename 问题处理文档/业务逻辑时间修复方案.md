# 业务逻辑时间修复方案

## 🎯 业务逻辑问题分析

经过检查，发现业务逻辑方面确实存在时区处理不一致的问题：

### 1. 问题发现

#### 1.1 `utils/common.js` 中的问题
```javascript
// 问题代码：使用普通moment，没有时区支持
static validateDiningTime(diningDate, mealType, allowFlexible = false) {
  const diningMoment = moment(diningDate);  // ❌ 没有时区处理
  const now = moment();                     // ❌ 服务器本地时间
  
  // 如果是当天，检查是否在合理时间范围内
  if (diningMoment.isSame(now, 'day')) {
    const currentHour = now.hour();  // ❌ 基于服务器本地时间
    // ...
  }
}
```

#### 1.2 `services/diningConfirmationService.js` 中的问题
```javascript
// 问题代码：混合使用时区处理
const diningDate = moment(order.diningDate).tz('Asia/Shanghai');  // ✅ 正确
const now = moment().tz('Asia/Shanghai');                          // ✅ 正确
const actualDiningTime = now.format('YYYY-MM-DD HH:mm:ss');       // ❌ 存储本地时间格式
```

## 🛠️ 业务逻辑修复方案

### 1. 修复 `utils/common.js`

#### 1.1 修复时间验证逻辑
```javascript
// 修复前的问题代码
static validateDiningTime(diningDate, mealType, allowFlexible = false) {
  const diningMoment = moment(diningDate);  // ❌ 没有时区处理
  const now = moment();                     // ❌ 服务器本地时间
  
  // 如果是当天，检查是否在合理时间范围内
  if (diningMoment.isSame(now, 'day')) {
    const currentHour = now.hour();  // ❌ 基于服务器本地时间
    // ...
  }
}

// 修复后的正确代码
static validateDiningTime(diningDate, mealType, allowFlexible = false) {
  const diningMoment = moment(diningDate).tz('Asia/Shanghai');  // ✅ 使用北京时间
  const now = moment().tz('Asia/Shanghai');                    // ✅ 使用北京时间
  
  // 如果是当天，检查是否在合理时间范围内
  if (diningMoment.isSame(now, 'day')) {
    const mealTimeRanges = {
      'breakfast': { start: 6, end: 10 },
      'lunch': { start: 11, end: 14 },
      'dinner': { start: 17, end: 20 }
    };

    const range = mealTimeRanges[mealType];
    if (range) {
      const currentHour = now.hour();  // ✅ 北京时间的小时数
      
      if (!allowFlexible && (currentHour < range.start || currentHour > range.end)) {
        throw new BusinessError(
          `不在${this.getMealTypeName(mealType)}时间范围内（${range.start}:00-${range.end}:00）`,
          ERROR_CODES.INVALID_DINING_TIME
        );
      }
    }
  }

  // 不能提前太多确认（超过1天）
  if (diningMoment.isAfter(now.add(1, 'day'))) {
    throw new BusinessError('不能提前超过1天确认就餐', ERROR_CODES.INVALID_DINING_TIME);
  }
}
```

### 2. 修复 `services/diningConfirmationService.js`

#### 2.1 修复确认就餐时间处理
```javascript
// 修复前的问题代码
const actualDiningTime = now.format('YYYY-MM-DD HH:mm:ss');  // ❌ 本地时间格式

await connection.execute(
  `UPDATE dining_orders 
   SET diningStatus = 'dined', 
       actualDiningTime = ?,
       updateTime = NOW()
   WHERE _id = ?`,
  [actualDiningTime, orderId]  // ❌ 存储本地时间格式
);

// 修复后的正确代码
const utcActualDiningTime = now.utc().toDate();  // ✅ 转换为UTC时间存储

await connection.execute(
  `UPDATE dining_orders 
   SET diningStatus = 'dined', 
       actualDiningTime = ?,
       updateTime = NOW()
   WHERE _id = ?`,
  [utcActualDiningTime, orderId]  // ✅ 存储UTC时间
);
```

### 3. 修复 `services/diningService.js`

#### 3.1 修复报餐时间验证
```javascript
// 修复前的问题代码
async submitDeptOrder(userId, date, mealType, memberIds, remark, db) {
  try {
    // 1. 验证报餐日期（不能是过去的日期）
    const today = moment().tz('Asia/Shanghai').format('YYYY-MM-DD');  // ✅ 正确
    if (moment(date).isBefore(today)) {
      throw new Error('不能为过去的日期报餐');
    }
    
    // ❌ 缺少时间存储逻辑
    await db.execute(
      `INSERT INTO dining_orders 
       (_id, deptId, deptName, registrantId, userId, userName, memberIds, memberNames, memberCount, 
        diningDate, mealType, status, diningStatus, remark, createTime, updateTime)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', 'ordered', ?, NOW(), NOW())`,
      [/* 参数列表 */]
    );
  }
}

// 修复后的正确代码
async submitDeptOrder(userId, date, mealType, memberIds, remark, db) {
  try {
    // 1. 验证报餐日期（不能是过去的日期）
    const today = moment().tz('Asia/Shanghai').format('YYYY-MM-DD');
    if (moment(date).isBefore(today)) {
      throw new Error('不能为过去的日期报餐');
    }
    
    // 2. 正确处理报餐时间
    const now = moment().tz('Asia/Shanghai');  // ✅ 获取当前北京时间
    const utcNow = now.utc().toDate();         // ✅ 转换为UTC时间存储
    
    // 3. 创建订单时使用正确的时间
    await db.execute(
      `INSERT INTO dining_orders 
       (_id, deptId, deptName, registrantId, userId, userName, memberIds, memberNames, memberCount, 
        diningDate, mealType, status, diningStatus, remark, registerTime, createTime, updateTime)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', 'ordered', ?, ?, ?, NOW())`,
      [
        orderId,
        registrant.departmentId,
        registrant.department,
        userId,
        userId,
        registrant.nickName,
        JSON.stringify(memberIds),
        JSON.stringify(memberNames),
        memberIds.length,
        date,
        mealType,
        remark || '',
        utcNow,  // ✅ 正确的UTC时间
        utcNow,  // ✅ 正确的UTC时间
        utcNow   // ✅ 正确的UTC时间
      ]
    );
  }
}
```

### 4. 修复 `services/qrScanService.js`

#### 4.1 确保扫码服务使用正确的时区处理
```javascript
// 确保扫码服务使用正确的时区处理
async processQRScan(userId, qrCode, scanTime, db) {
  // ...
  
  // 2. 根据扫码时间判断餐次（使用北京时间）
  const beijingScanTime = moment(scanTime).tz('Asia/Shanghai');
  const mealType = this.getMealTypeByTime(beijingScanTime.toDate());
  if (!mealType) {
    throw new Error('当前时间不在就餐时间内');
  }
  
  // 使用北京时间的日期
  const diningDate = beijingScanTime.format('YYYY-MM-DD');
  
  // 6. 创建就餐登记记录
  const registrationId = uuidv4();
  // ✅ 存储UTC时间到数据库
  const utcScanTime = moment(scanTime).utc().toDate();
  
  await connection.execute(`
    INSERT INTO dining_registrations 
    (_id, userId, userName, qrCodeId, qrCode, scanTime, mealType, diningDate, orderId, status)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'success')
  `, [
    registrationId,
    userId,
    userInfo.nickName,
    qrCodeInfo._id,
    qrCode,
    utcScanTime,  // ✅ 存储UTC时间
    mealType,
    diningDate,
    orderInfo._id
  ]);
}
```

## 📋 业务逻辑修复步骤

### 第一步：修复时间验证工具
1. **修复 `utils/common.js`**：使用 `moment-timezone` 进行时区处理
2. **修复 `utils/timeUtils.js`**：确保时间工具类使用正确的时区

### 第二步：修复服务层业务逻辑
1. **修复 `services/diningService.js`**：正确处理报餐时间存储
2. **修复 `services/diningServiceEnhanced.js`**：确保增强版服务也使用正确的时间处理
3. **修复 `services/diningConfirmationService.js`**：修复确认就餐时间处理
4. **确保 `services/qrScanService.js`**：使用正确的时区处理

### 第三步：修复控制器层
1. **修复 `controllers/diningController.js`**：确保控制器使用正确的时间处理
2. **修复 `controllers/diningControllerEnhanced.js`**：确保增强版控制器也使用正确的时间处理

### 第四步：测试验证
1. **运行业务逻辑测试**：确保所有业务规则正确执行
2. **运行时间修复测试**：确保时间处理正确
3. **运行集成测试**：确保整个流程正确

## 🔧 具体修复代码

### 1. 修复 `utils/common.js`

```javascript
const moment = require('moment-timezone');  // ✅ 使用支持时区的moment

class CommonUtils {
  /**
   * 验证就餐时间
   * @param {string} diningDate - 就餐日期
   * @param {string} mealType - 餐次类型
   * @param {boolean} allowFlexible - 是否允许灵活时间
   */
  static validateDiningTime(diningDate, mealType, allowFlexible = false) {
    const diningMoment = moment(diningDate).tz('Asia/Shanghai');  // ✅ 使用北京时间
    const now = moment().tz('Asia/Shanghai');                    // ✅ 使用北京时间

    // 如果是当天，检查是否在合理时间范围内
    if (diningMoment.isSame(now, 'day')) {
      const mealTimeRanges = {
        'breakfast': { start: 6, end: 10 },
        'lunch': { start: 11, end: 14 },
        'dinner': { start: 17, end: 20 }
      };

      const range = mealTimeRanges[mealType];
      if (range) {
        const currentHour = now.hour();  // ✅ 北京时间的小时数
        
        if (!allowFlexible && (currentHour < range.start || currentHour > range.end)) {
          throw new BusinessError(
            `不在${this.getMealTypeName(mealType)}时间范围内（${range.start}:00-${range.end}:00）`,
            ERROR_CODES.INVALID_DINING_TIME
          );
        }
      }
    }

    // 不能提前太多确认（超过1天）
    if (diningMoment.isAfter(now.add(1, 'day'))) {
      throw new BusinessError('不能提前超过1天确认就餐', ERROR_CODES.INVALID_DINING_TIME);
    }
  }
}
```

### 2. 修复 `services/diningConfirmationService.js`

```javascript
const moment = require('moment-timezone');  // ✅ 使用支持时区的moment

class DiningConfirmationService {
  async confirmDiningManually(userId, orderId, confirmationType = 'manual', db) {
    // ...
    
    // 3. 检查确认时间是否合理（不能提前太多确认）
    const diningDate = moment(order.diningDate).tz('Asia/Shanghai');
    const now = moment().tz('Asia/Shanghai');  // ✅ 使用北京时间
    
    // 如果是当天，检查是否在合理时间范围内
    if (diningDate.isSame(now, 'day')) {
      const mealType = order.mealType;
      const currentHour = now.hour();  // ✅ 北京时间的小时数
      
      // 检查是否在就餐时间范围内
      const mealTimeRanges = {
        'breakfast': { start: 6, end: 10 },
        'lunch': { start: 11, end: 14 },
        'dinner': { start: 17, end: 20 }
      };
      
      const timeRange = mealTimeRanges[mealType];
      if (timeRange && (currentHour < timeRange.start || currentHour > timeRange.end)) {
        throw new Error(`当前时间不在${this.getMealTypeName(mealType)}就餐时间内`);
      }
    }

    // 4. 更新订单状态
    const utcActualDiningTime = now.utc().toDate();  // ✅ 转换为UTC时间存储
    
    await connection.execute(
      `UPDATE dining_orders 
       SET diningStatus = 'dined', 
           actualDiningTime = ?,
           updateTime = NOW()
       WHERE _id = ?`,
      [utcActualDiningTime, orderId]  // ✅ 存储UTC时间
    );
  }
}
```

## 🎯 业务逻辑修复效果

### 修复前的问题
1. **时间验证不准确**：使用服务器本地时间进行业务逻辑判断
2. **时间存储不一致**：混合使用本地时间和UTC时间
3. **餐次判断错误**：基于错误的时间进行餐次判断
4. **确认就餐时间错误**：存储错误的确认就餐时间

### 修复后的效果
1. **时间验证准确**：统一使用北京时间进行业务逻辑判断
2. **时间存储一致**：统一存储UTC时间到数据库
3. **餐次判断正确**：基于正确的北京时间进行餐次判断
4. **确认就餐时间正确**：存储正确的确认就餐时间

## ⚠️ 注意事项

1. **依赖更新**：确保所有相关文件都使用 `moment-timezone`
2. **业务规则**：确保所有业务规则都基于北京时间进行判断
3. **数据一致性**：确保所有时间数据都统一存储为UTC时间
4. **测试验证**：修复后需要全面测试所有业务逻辑

## 📝 总结

业务逻辑方面的修复是时间修复方案的重要组成部分，包括：

1. **时间验证逻辑**：统一使用北京时间进行业务规则验证
2. **时间存储逻辑**：统一存储UTC时间到数据库
3. **餐次判断逻辑**：基于正确的北京时间进行餐次判断
4. **确认就餐逻辑**：正确处理确认就餐时间

修复完成后，整个报餐系统的业务逻辑将基于正确的时间处理，确保所有功能都能正常工作。
