# 前端时间数据处理指南

## 概述

后端返回的时间数据格式为ISO 8601标准格式：`YYYY-MM-DDTHH:mm:ss.sssZ`（UTC时间）。前端需要根据不同场景进行格式化和处理。

## 后端时间数据格式

### 1. 完整时间戳
```json
{
  "createTime": "2024-01-15T10:30:00.000Z",
  "updateTime": "2024-01-15T14:25:30.500Z"
}
```

### 2. 日期格式
```json
{
  "date": "2024-01-15",
  "joinDate": "2024-01-01"
}
```

### 3. 时间格式
```json
{
  "startTime": "14:00",
  "endTime": "16:00",
  "openTime": "08:00",
  "closeTime": "22:00"
}
```

## 前端处理方案

### 1. JavaScript原生处理

#### 1.1 创建时间工具类
```javascript
class TimeUtils {
  /**
   * 解析后端时间字符串为Date对象
   * @param {string} timeString - 后端时间字符串
   * @returns {Date} Date对象
   */
  static parseTime(timeString) {
    if (!timeString) return null;
    return new Date(timeString);
  }

  /**
   * 格式化时间为本地时间字符串
   * @param {string|Date} time - 时间字符串或Date对象
   * @param {string} format - 格式类型
   * @returns {string} 格式化后的时间字符串
   */
  static formatTime(time, format = 'YYYY-MM-DD HH:mm:ss') {
    const date = typeof time === 'string' ? this.parseTime(time) : time;
    if (!date) return '';

    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');

    switch (format) {
      case 'YYYY-MM-DD':
        return `${year}-${month}-${day}`;
      case 'YYYY-MM-DD HH:mm':
        return `${year}-${month}-${day} ${hours}:${minutes}`;
      case 'YYYY-MM-DD HH:mm:ss':
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
      case 'MM-DD HH:mm':
        return `${month}-${day} ${hours}:${minutes}`;
      case 'HH:mm':
        return `${hours}:${minutes}`;
      case 'relative':
        return this.getRelativeTime(date);
      default:
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }
  }

  /**
   * 获取相对时间（如：3分钟前、2小时前）
   * @param {Date} date - 日期对象
   * @returns {string} 相对时间字符串
   */
  static getRelativeTime(date) {
    const now = new Date();
    const diff = now - date;
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    if (days > 0) return `${days}天前`;
    if (hours > 0) return `${hours}小时前`;
    if (minutes > 0) return `${minutes}分钟前`;
    return '刚刚';
  }

  /**
   * 获取当前日期字符串（YYYY-MM-DD格式）
   * @returns {string} 当前日期
   */
  static getCurrentDate() {
    return this.formatTime(new Date(), 'YYYY-MM-DD');
  }

  /**
   * 获取当前时间字符串（HH:mm格式）
   * @returns {string} 当前时间
   */
  static getCurrentTime() {
    return this.formatTime(new Date(), 'HH:mm');
  }

  /**
   * 计算时间差（分钟）
   * @param {string|Date} startTime - 开始时间
   * @param {string|Date} endTime - 结束时间
   * @returns {number} 时间差（分钟）
   */
  static getTimeDiff(startTime, endTime) {
    const start = typeof startTime === 'string' ? this.parseTime(startTime) : startTime;
    const end = typeof endTime === 'string' ? this.parseTime(endTime) : endTime;
    return Math.floor((end - start) / (1000 * 60));
  }

  /**
   * 验证时间格式
   * @param {string} timeString - 时间字符串
   * @returns {boolean} 是否有效
   */
  static isValidTime(timeString) {
    if (!timeString) return false;
    const date = new Date(timeString);
    return !isNaN(date.getTime());
  }
}
```

#### 1.2 使用示例
```javascript
// 解析后端时间
const createTime = TimeUtils.parseTime("2024-01-15T10:30:00.000Z");
console.log(createTime); // Mon Jan 15 2024 18:30:00 GMT+0800 (本地时间)

// 格式化时间
const formattedTime = TimeUtils.formatTime("2024-01-15T10:30:00.000Z", "YYYY-MM-DD HH:mm");
console.log(formattedTime); // "2024-01-15 18:30"

// 相对时间
const relativeTime = TimeUtils.formatTime("2024-01-15T10:30:00.000Z", "relative");
console.log(relativeTime); // "2小时前" (根据当前时间)

// 获取当前日期
const currentDate = TimeUtils.getCurrentDate();
console.log(currentDate); // "2024-01-15"

// 计算时间差
const diff = TimeUtils.getTimeDiff("2024-01-15T14:00:00.000Z", "2024-01-15T16:00:00.000Z");
console.log(diff); // 120 (分钟)
```

### 2. 使用第三方库（推荐）

#### 2.1 安装day.js（轻量级）
```bash
npm install dayjs
```

#### 2.2 day.js配置和使用
```javascript
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';
import 'dayjs/locale/zh-cn'; // 中文语言包

// 配置插件
dayjs.extend(relativeTime);
dayjs.locale('zh-cn');

class TimeUtils {
  /**
   * 格式化时间
   * @param {string|Date} time - 时间
   * @param {string} format - 格式
   * @returns {string} 格式化后的时间
   */
  static format(time, format = 'YYYY-MM-DD HH:mm:ss') {
    return dayjs(time).format(format);
  }

  /**
   * 获取相对时间
   * @param {string|Date} time - 时间
   * @returns {string} 相对时间
   */
  static fromNow(time) {
    return dayjs(time).fromNow();
  }

  /**
   * 获取当前时间
   * @param {string} format - 格式
   * @returns {string} 当前时间
   */
  static now(format = 'YYYY-MM-DD HH:mm:ss') {
    return dayjs().format(format);
  }

  /**
   * 验证时间
   * @param {string} time - 时间字符串
   * @returns {boolean} 是否有效
   */
  static isValid(time) {
    return dayjs(time).isValid();
  }

  /**
   * 时间比较
   * @param {string|Date} time1 - 时间1
   * @param {string|Date} time2 - 时间2
   * @returns {number} 比较结果
   */
  static compare(time1, time2) {
    return dayjs(time1).diff(dayjs(time2));
  }
}
```

### 3. Vue.js组件中的使用

#### 3.1 全局过滤器（Vue 2）
```javascript
// main.js
import Vue from 'vue';
import TimeUtils from '@/utils/TimeUtils';

Vue.filter('formatTime', function(time, format) {
  return TimeUtils.formatTime(time, format);
});

Vue.filter('relativeTime', function(time) {
  return TimeUtils.formatTime(time, 'relative');
});
```

#### 3.2 在模板中使用
```vue
<template>
  <div>
    <!-- 格式化时间 -->
    <p>创建时间: {{ item.createTime | formatTime('YYYY-MM-DD HH:mm') }}</p>
    
    <!-- 相对时间 -->
    <p>更新时间: {{ item.updateTime | relativeTime }}</p>
    
    <!-- 日期 -->
    <p>日期: {{ item.date }}</p>
    
    <!-- 时间 -->
    <p>时间: {{ item.startTime }}</p>
  </div>
</template>
```

#### 3.3 Vue 3 Composition API
```vue
<template>
  <div>
    <p>创建时间: {{ formatTime(item.createTime, 'YYYY-MM-DD HH:mm') }}</p>
    <p>更新时间: {{ getRelativeTime(item.updateTime) }}</p>
  </div>
</template>

<script setup>
import { computed } from 'vue';
import TimeUtils from '@/utils/TimeUtils';

const props = defineProps(['item']);

const formatTime = (time, format) => {
  return TimeUtils.formatTime(time, format);
};

const getRelativeTime = (time) => {
  return TimeUtils.formatTime(time, 'relative');
};
</script>
```

### 4. React组件中的使用

#### 4.1 自定义Hook
```javascript
// hooks/useTime.js
import { useMemo } from 'react';
import TimeUtils from '@/utils/TimeUtils';

export const useTime = () => {
  const formatTime = useMemo(() => {
    return (time, format) => TimeUtils.formatTime(time, format);
  }, []);

  const getRelativeTime = useMemo(() => {
    return (time) => TimeUtils.formatTime(time, 'relative');
  }, []);

  return {
    formatTime,
    getRelativeTime,
    getCurrentDate: TimeUtils.getCurrentDate,
    getCurrentTime: TimeUtils.getCurrentTime
  };
};
```

#### 4.2 在组件中使用
```jsx
import React from 'react';
import { useTime } from '@/hooks/useTime';

const TimeDisplay = ({ item }) => {
  const { formatTime, getRelativeTime } = useTime();

  return (
    <div>
      <p>创建时间: {formatTime(item.createTime, 'YYYY-MM-DD HH:mm')}</p>
      <p>更新时间: {getRelativeTime(item.updateTime)}</p>
    </div>
  );
};

export default TimeDisplay;
```

### 5. 表格中的时间显示

#### 5.1 Vue表格组件
```vue
<template>
  <el-table :data="tableData">
    <el-table-column prop="createTime" label="创建时间">
      <template #default="{ row }">
        {{ formatTime(row.createTime, 'YYYY-MM-DD HH:mm') }}
      </template>
    </el-table-column>
    
    <el-table-column prop="updateTime" label="更新时间">
      <template #default="{ row }">
        <span :title="formatTime(row.updateTime, 'YYYY-MM-DD HH:mm:ss')">
          {{ getRelativeTime(row.updateTime) }}
        </span>
      </template>
    </el-table-column>
  </el-table>
</template>

<script setup>
import TimeUtils from '@/utils/TimeUtils';

const formatTime = (time, format) => TimeUtils.formatTime(time, format);
const getRelativeTime = (time) => TimeUtils.formatTime(time, 'relative');
</script>
```

#### 5.2 React表格组件
```jsx
import React from 'react';
import { Table } from 'antd';
import TimeUtils from '@/utils/TimeUtils';

const DataTable = ({ data }) => {
  const columns = [
    {
      title: '创建时间',
      dataIndex: 'createTime',
      key: 'createTime',
      render: (time) => TimeUtils.formatTime(time, 'YYYY-MM-DD HH:mm')
    },
    {
      title: '更新时间',
      dataIndex: 'updateTime',
      key: 'updateTime',
      render: (time) => (
        <span title={TimeUtils.formatTime(time, 'YYYY-MM-DD HH:mm:ss')}>
          {TimeUtils.formatTime(time, 'relative')}
        </span>
      )
    }
  ];

  return <Table columns={columns} dataSource={data} />;
};

export default DataTable;
```

### 6. 表单中的时间处理

#### 6.1 日期选择器
```vue
<template>
  <el-form>
    <el-form-item label="日期">
      <el-date-picker
        v-model="form.date"
        type="date"
        placeholder="选择日期"
        format="YYYY-MM-DD"
        value-format="YYYY-MM-DD"
      />
    </el-form-item>
    
    <el-form-item label="时间">
      <el-time-picker
        v-model="form.time"
        placeholder="选择时间"
        format="HH:mm"
        value-format="HH:mm"
      />
    </el-form-item>
  </el-form>
</template>

<script setup>
import { ref } from 'vue';

const form = ref({
  date: TimeUtils.getCurrentDate(),
  time: TimeUtils.getCurrentTime()
});
</script>
```

#### 6.2 时间范围选择
```vue
<template>
  <el-form>
    <el-form-item label="时间范围">
      <el-date-picker
        v-model="form.dateRange"
        type="datetimerange"
        range-separator="至"
        start-placeholder="开始时间"
        end-placeholder="结束时间"
        format="YYYY-MM-DD HH:mm"
        value-format="YYYY-MM-DDTHH:mm:ss.sssZ"
      />
    </el-form-item>
  </el-form>
</template>
```

### 7. 常见时间处理场景

#### 7.1 预约时间处理
```javascript
// 预约时间验证
const validateReservationTime = (date, startTime, endTime) => {
  const now = new Date();
  const reservationDate = new Date(`${date}T${startTime}:00`);
  
  // 检查是否在未来
  if (reservationDate <= now) {
    return { valid: false, message: '预约时间必须是未来时间' };
  }
  
  // 检查时间范围
  const start = TimeUtils.parseTime(`2000-01-01T${startTime}:00`);
  const end = TimeUtils.parseTime(`2000-01-01T${endTime}:00`);
  const duration = TimeUtils.getTimeDiff(start, end);
  
  if (duration <= 0) {
    return { valid: false, message: '结束时间必须晚于开始时间' };
  }
  
  return { valid: true };
};
```

#### 7.2 报餐时间处理
```javascript
// 报餐时间限制
const getMealOrderDeadline = (mealType) => {
  const now = new Date();
  const today = TimeUtils.getCurrentDate();
  
  switch (mealType) {
    case 'breakfast':
      return `${today}T08:00:00.000Z`; // 早餐8点前
    case 'lunch':
      return `${today}T11:00:00.000Z`; // 午餐11点前
    case 'dinner':
      return `${today}T16:00:00.000Z`; // 晚餐16点前
    default:
      return null;
  }
};

const canOrderMeal = (mealType) => {
  const deadline = getMealOrderDeadline(mealType);
  if (!deadline) return false;
  
  return new Date() < new Date(deadline);
};
```

#### 7.3 时间状态显示
```javascript
// 订单状态时间显示
const getOrderTimeStatus = (order) => {
  const now = new Date();
  const createTime = TimeUtils.parseTime(order.createTime);
  const diff = TimeUtils.getTimeDiff(createTime, now);
  
  if (diff < 5) return { status: 'new', text: '刚刚下单', color: 'green' };
  if (diff < 30) return { status: 'recent', text: `${diff}分钟前下单`, color: 'blue' };
  if (diff < 60) return { status: 'old', text: `${Math.floor(diff / 60)}小时前下单`, color: 'orange' };
  return { status: 'very-old', text: '很久前下单', color: 'red' };
};
```

### 8. 性能优化建议

#### 8.1 时间格式化缓存
```javascript
class TimeCache {
  static cache = new Map();
  
  static format(time, format) {
    const key = `${time}_${format}`;
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    
    const formatted = TimeUtils.formatTime(time, format);
    this.cache.set(key, formatted);
    return formatted;
  }
  
  static clear() {
    this.cache.clear();
  }
}
```

#### 8.2 虚拟滚动中的时间处理
```javascript
// 大列表中的时间显示优化
const TimeCell = ({ time, format }) => {
  const [formattedTime, setFormattedTime] = useState('');
  
  useEffect(() => {
    // 延迟格式化，避免阻塞渲染
    const timer = setTimeout(() => {
      setFormattedTime(TimeUtils.formatTime(time, format));
    }, 0);
    
    return () => clearTimeout(timer);
  }, [time, format]);
  
  return <span>{formattedTime}</span>;
};
```

### 9. 错误处理

#### 9.1 时间解析错误处理
```javascript
const safeFormatTime = (time, format = 'YYYY-MM-DD HH:mm:ss') => {
  try {
    if (!time) return '--';
    if (!TimeUtils.isValidTime(time)) return '无效时间';
    return TimeUtils.formatTime(time, format);
  } catch (error) {
    console.error('时间格式化错误:', error);
    return '--';
  }
};
```

#### 9.2 时区处理
```javascript
// 处理不同时区的时间
const formatTimeWithTimezone = (time, timezone = 'Asia/Shanghai') => {
  try {
    const date = new Date(time);
    return date.toLocaleString('zh-CN', {
      timeZone: timezone,
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  } catch (error) {
    console.error('时区转换错误:', error);
    return TimeUtils.formatTime(time);
  }
};
```

## 总结

1. **统一工具类**: 创建统一的时间处理工具类，封装所有时间相关操作
2. **格式化显示**: 根据场景选择合适的显示格式
3. **相对时间**: 对于最近的时间使用相对时间显示
4. **错误处理**: 添加完善的错误处理机制
5. **性能优化**: 对大量数据使用缓存和延迟处理
6. **用户体验**: 提供清晰的时间信息和状态提示

通过这些方案，前端可以优雅地处理后端传递的各种时间数据，提供良好的用户体验。
