# 前端报餐请求时间要求说明

## 📋 概述

本文档详细说明前端在发起报餐请求时需要遵循的时间要求和限制规则。

## 🎯 核心时间要求

### 1. 报餐日期限制

#### 1.1 基本规则
- **不能为过去的日期报餐**
- **可以报餐的日期**：今天及未来的日期
- **日期格式**：`YYYY-MM-DD`（如：`2025-09-11`）

#### 1.2 具体实现
```javascript
// 后端验证逻辑
const today = moment().tz('Asia/Shanghai').format('YYYY-MM-DD');
if (moment(date).isBefore(today)) {
  throw new Error('不能为过去的日期报餐');
}
```

#### 1.3 前端处理建议
```javascript
// 前端日期选择器限制
const today = moment().format('YYYY-MM-DD');
const minDate = today; // 最小可选日期为今天

// 日期选择器配置
<DatePicker 
  minDate={minDate}
  format="YYYY-MM-DD"
  placeholder="选择用餐日期"
/>
```

### 2. 报餐时间限制

#### 2.1 餐次时间范围
| 餐次类型 | 时间范围 | 说明 |
|---------|---------|------|
| breakfast | 06:00-10:00 | 早餐时间 |
| lunch | 11:00-14:00 | 午餐时间 |
| dinner | 17:00-20:00 | 晚餐时间 |

#### 2.2 时间验证规则
```javascript
// 后端验证逻辑
const mealTimeRanges = {
  'breakfast': { start: 6, end: 10 },
  'lunch': { start: 11, end: 14 },
  'dinner': { start: 17, end: 20 }
};

// 如果是当天报餐，检查是否在合理时间范围内
if (diningMoment.isSame(now, 'day')) {
  const currentHour = now.hour();
  const range = mealTimeRanges[mealType];
  
  if (currentHour < range.start || currentHour > range.end) {
    throw new Error(`不在${mealTypeName}时间范围内（${range.start}:00-${range.end}:00）`);
  }
}
```

### 3. 前端请求参数要求

#### 3.1 请求格式
```javascript
// POST /api/dining/dept-order
{
  "date": "2025-09-11",           // 必填：用餐日期 YYYY-MM-DD
  "mealType": "lunch",            // 必填：餐次类型
  "memberIds": ["user1", "user2"], // 必填：成员ID列表
  "remark": "备注信息"             // 可选：备注，最多500字符
}
```

#### 3.2 参数验证
```javascript
// 前端验证逻辑
const validateMealOrder = (orderData) => {
  const errors = [];
  
  // 验证日期
  if (!orderData.date) {
    errors.push('用餐日期不能为空');
  } else if (moment(orderData.date).isBefore(moment(), 'day')) {
    errors.push('不能为过去的日期报餐');
  }
  
  // 验证餐次类型
  const validMealTypes = ['breakfast', 'lunch', 'dinner'];
  if (!validMealTypes.includes(orderData.mealType)) {
    errors.push('餐次类型无效');
  }
  
  // 验证成员列表
  if (!orderData.memberIds || orderData.memberIds.length === 0) {
    errors.push('至少选择一名成员');
  }
  
  // 验证备注长度
  if (orderData.remark && orderData.remark.length > 500) {
    errors.push('备注最多500个字符');
  }
  
  return errors;
};
```

## 🕐 时间处理最佳实践

### 1. 前端时间处理

#### 1.1 使用moment-timezone
```javascript
import moment from 'moment-timezone';

// 获取当前北京时间
const now = moment().tz('Asia/Shanghai');

// 格式化日期
const today = now.format('YYYY-MM-DD');

// 检查是否为今天
const isToday = moment(date).isSame(now, 'day');
```

#### 1.2 时间验证工具函数
```javascript
// 时间验证工具类
class TimeValidator {
  // 检查是否可以报餐
  static canRegisterMeal(date) {
    const beijingDate = moment(date).tz('Asia/Shanghai');
    const today = moment().tz('Asia/Shanghai');
    
    // 不能为过去的日期报餐
    return !beijingDate.isBefore(today, 'day');
  }
  
  // 检查是否在就餐时间内
  static isInDiningTime(mealType, time = null) {
    const checkTime = time ? moment(time).tz('Asia/Shanghai') : moment().tz('Asia/Shanghai');
    const hour = checkTime.hour();
    
    const mealTimeRanges = {
      'breakfast': { start: 6, end: 10 },
      'lunch': { start: 11, end: 14 },
      'dinner': { start: 17, end: 20 }
    };
    
    const timeRange = mealTimeRanges[mealType];
    return timeRange && hour >= timeRange.start && hour <= timeRange.end;
  }
  
  // 获取餐次时间范围描述
  static getMealTimeRangeDescription(mealType) {
    const mealTimeRanges = {
      'breakfast': '06:00-10:00',
      'lunch': '11:00-14:00',
      'dinner': '17:00-20:00'
    };
    
    return mealTimeRanges[mealType] || '未知时间范围';
  }
}
```

### 2. 用户体验优化

#### 2.1 智能日期选择
```javascript
// 智能日期选择器
const SmartDatePicker = () => {
  const [selectedDate, setSelectedDate] = useState(null);
  const [mealType, setMealType] = useState('lunch');
  
  // 获取可选日期范围
  const getAvailableDates = () => {
    const dates = [];
    const today = moment().tz('Asia/Shanghai');
    
    // 提供未来7天的选择
    for (let i = 0; i < 7; i++) {
      const date = today.clone().add(i, 'days');
      dates.push({
        value: date.format('YYYY-MM-DD'),
        label: date.format('MM月DD日'),
        disabled: i === 0 && !TimeValidator.isInDiningTime(mealType) // 今天不在就餐时间内则禁用
      });
    }
    
    return dates;
  };
  
  return (
    <Select 
      options={getAvailableDates()}
      value={selectedDate}
      onChange={setSelectedDate}
      placeholder="选择用餐日期"
    />
  );
};
```

#### 2.2 实时时间提示
```javascript
// 时间提示组件
const TimeHint = ({ mealType, date }) => {
  const now = moment().tz('Asia/Shanghai');
  const isToday = moment(date).isSame(now, 'day');
  
  if (!isToday) {
    return <div className="time-hint">✅ 可以报餐</div>;
  }
  
  const isInTime = TimeValidator.isInDiningTime(mealType);
  const timeRange = TimeValidator.getMealTimeRangeDescription(mealType);
  
  if (isInTime) {
    return <div className="time-hint success">✅ 当前时间可以报餐 ({timeRange})</div>;
  } else {
    return <div className="time-hint warning">⚠️ 当前时间不在就餐时间内 ({timeRange})</div>;
  }
};
```

## 🚫 常见错误处理

### 1. 错误码和消息

| 错误码 | 错误消息 | 解决方案 |
|-------|---------|---------|
| 400 | 不能为过去的日期报餐 | 选择今天或未来的日期 |
| 400 | 不在早餐时间范围内（6:00-10:00） | 在就餐时间内报餐 |
| 400 | 不在午餐时间范围内（11:00-14:00） | 在就餐时间内报餐 |
| 400 | 不在晚餐时间范围内（17:00-20:00） | 在就餐时间内报餐 |
| 400 | 至少选择一名成员 | 选择报餐成员 |
| 400 | 备注最多500个字符 | 缩短备注内容 |

### 2. 前端错误处理
```javascript
// 错误处理示例
const handleSubmitOrder = async (orderData) => {
  try {
    // 前端验证
    const errors = validateMealOrder(orderData);
    if (errors.length > 0) {
      showError(errors.join('; '));
      return;
    }
    
    // 发送请求
    const response = await api.post('/api/dining/dept-order', orderData);
    
    if (response.data.success) {
      showSuccess('报餐成功！');
    }
  } catch (error) {
    if (error.response?.data?.message) {
      showError(error.response.data.message);
    } else {
      showError('报餐失败，请重试');
    }
  }
};
```

## 📱 移动端适配

### 1. 时间选择器优化
```javascript
// 移动端友好的时间选择
const MobileTimePicker = () => {
  return (
    <div className="mobile-time-picker">
      <DatePicker
        mode="date"
        format="YYYY-MM-DD"
        minDate={moment().format('YYYY-MM-DD')}
        showToday={false}
        placeholder="选择日期"
      />
      
      <TimePicker
        mode="time"
        format="HH:mm"
        minuteStep={30}
        placeholder="选择时间"
      />
    </div>
  );
};
```

### 2. 响应式布局
```css
/* 移动端时间选择器样式 */
.mobile-time-picker {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

@media (min-width: 768px) {
  .mobile-time-picker {
    flex-direction: row;
    gap: 24px;
  }
}
```

## 🔧 配置建议

### 1. 环境配置
```javascript
// 时区配置
const TIMEZONE = 'Asia/Shanghai';

// 餐次时间配置
const MEAL_TIME_RANGES = {
  breakfast: { start: 6, end: 10 },
  lunch: { start: 11, end: 14 },
  dinner: { start: 17, end: 20 }
};

// 报餐限制配置
const MEAL_ORDER_LIMITS = {
  maxAdvanceDays: 7,        // 最多提前7天报餐
  maxMembersPerOrder: 50,    // 单次最多50人
  maxRemarkLength: 500       // 备注最多500字符
};
```

### 2. 国际化支持
```javascript
// 多语言时间格式
const TIME_FORMATS = {
  'zh-CN': 'YYYY年MM月DD日',
  'en-US': 'MM/DD/YYYY',
  'zh-TW': 'YYYY年MM月DD日'
};

// 餐次名称多语言
const MEAL_TYPE_NAMES = {
  'zh-CN': {
    breakfast: '早餐',
    lunch: '午餐',
    dinner: '晚餐'
  },
  'en-US': {
    breakfast: 'Breakfast',
    lunch: 'Lunch',
    dinner: 'Dinner'
  }
};
```

## 📝 总结

前端在发起报餐请求时需要遵循以下时间要求：

1. **日期限制**：不能为过去的日期报餐，只能选择今天及未来的日期
2. **时间范围**：如果选择今天报餐，需要在对应餐次的就餐时间内
3. **格式要求**：日期格式必须为 `YYYY-MM-DD`
4. **验证机制**：前端需要先进行客户端验证，后端会进行服务端验证
5. **用户体验**：提供智能的时间选择器和实时的时间提示

遵循这些要求可以确保报餐请求的成功提交，避免因时间问题导致的报餐失败。
